# Скриншоты
![group](img/group.png)

# Горячие клавишы
- **Смещение**: влево, вправо, вверх, вниз по стрелкам 
- **Масштабирование**: клавиши **+** и **-** для приближения и отдаления соответственно

# Цель работы
Изучить способы оптимизации программы на примере вычисления множества Мандельброта

# Материалы и методы
Для получения базового представления о векторизации вычислений с использованием **SIMD** команды (Single Instruction Multiple Data) я выбрал задачу построения множества Мандельброта. Вся работа проводилась на компьютере с процессором, поддерживающим набор инструкций **AVX512**

Оптимизация заключается в том, чтобы рассчитывать сразу несколько пикселей за раз. Расчёт цвета пикселя картинки производится на основании номера вылета. 
Основные формулы:
1. $r = \sqrt{x_1^2 + y_1^2}$
2. $x_1 = x_1^2 - y_1^2 + x_0$
3. $y_1 = 2 x_1 y_1 + y_0$

Как только $r$ выходит за заданный константный наибольший радиус, то расчёт точки прекращается, для неё записывается номер. По номеру уже можно по любой доступной формуле рассчитывать цвет пикселя. В моём варианте цвет пикселя рассчитывает просто линейной функцией

___

Одно из направлений векторизации заключается в векторизации условных ветвлений. Для этого используются маски, которые позволяют вычисляющим инструкциям не трогать пиксели, расчёт для которых был закончен. Чтобы не использовать ассемблерные вставки и позволить компилятору оптимизировать код, я использовал SIMD команды

# Ход работы
1. Написал наивную реализацю
2. Написал оптимизированную реализацию
3. Измерил производительность оптимизировнной и наивной версии с учётом и без оптимизации компилятором. 
4. Воспользовался инструментом godbolt.org и сравнил фрагменты кода на Си и инструкции, которые получаются на выходе компилятор
5. Рассмотрел наивную реализацию, которая рассчитывает каждый пиксель отдельно
6. Рассмотрел векторизованную версию с использованием SIMD команд
7. Сделал вывод

# Сравнение выхода компилятора
Компилятор не в силах понять смысл кода и начать обрабатывать сразу несколько пикселей за раз, как это делаем мы. Приведу сравнение фрагмента кода для расчёта номера вылета пикселей

```
    float x1_sqr   =          x1 * x1;
    float y1_sqr   =          y1 * y1;

    float dist_sqr = x1_sqr + y1 * y1;

    float dbl_x1y1 =      2 * x1 * y1;

    x1 = x1_sqr - y1_sqr + x0;
    y1 = dbl_x1y1        + y0;
```

## Наивная версия с `-O2`:
```
    movaps  xmm2, xmm0
    movaps  xmm3, xmm1
    mulss   xmm2, xmm0
    addss   xmm0, xmm0
    mulss   xmm3, xmm1
    mulss   xmm1, xmm0
    movaps  xmm4, xmm2
    subss   xmm2, xmm3
    addss   xmm4, xmm3
    addss   xmm1, xmm6
    movaps  xmm0, xmm2
    addss   xmm0, xmm5
```

Видно, что компилятор использует **XMM** регистры для расчётов с плавающей точкой, но этого недостаточно, чтобы ускорить производительность максимально, потому что делает он это лишь для одного пикселя. 

## Оптимизировнная версия с `-O2`:
```
    vmulps          zmm3, zmm0, zmm0
    vmovaps         zmm2, zmm1
    vmulps          zmm0, zmm1, zmm0
    vfmadd132ps     zmm2, zmm3, zmm1
    vfmsub132ps     zmm1, zmm3, zmm1
    vaddps          zmm0, zmm0, zmm0
    vaddps          zmm0, zmm0, zmm6
    vcmpps          k0,   zmm2, zmm7, 1
    vaddps          zmm1, zmm1, zmm5
    vpmovm2d        zmm2, k0
    vpaddd          zmm2, zmm2, zmm4
    vmovdqa64       zmm4, zmm2
```

Компилятор во всю использует **ZMM** регистры и сразу обрабатывает почти тем же количеством команд сразу 16 пикселей
___
Также компилятор имеет возможность оптимизировать интринсики. Чтобы показать различие в количестве используемых AVX команд, привожу [ссылку](https://godbolt.org/z/bo83e879x) для сравнения оптимизацию кода с интринсиками

# Результаты замеров
Чтобы замерить именно производительность вычисления, проводил вычисления картинки фиксированное количество раз, в моём случае 100, и с его учётом измерял количество кадров в секунду. Так я смог пренебречь затратами на отрисовку кадра по сравнению с её расчётом, искусственно сместив вес вычислений. 

Я привёл результаты замеров с флагами `-O0` и `-O2` для того, чтобы показать:
1. Компилятор пытается использовать **XMM** регистры для ускорения расчётов с плавающей точкой
2. Компилятор может оптимизировать код, написанный с использованием интринсиков, в отличие от кода с ассемблерными вставками

| FPS              | `-O0` | `-O2` |
|------------------|-------|-------|
| Оптимизированная | 15.42 | 64.14 |
| Наивная          | 2.84  | 5.19  |

# Вывод
Таким образом, исходя из данных в таблице, я получил ускорение программы (сравнивая версии с оптимизациями компилятора) примерно в 12 раз

