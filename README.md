# Цель работы
Изучить способы оптимизации программы на примере вычисления множества Мандельброта

# Скриншоты
![group](img/group.png)

# Горячие клавишы
- **Смещение**: влево, вправо, вверх, вниз по стрелкам 
- **Масштабирование**: клавиши **+** и **-** для приближения и отдаления соответственно

# Способы оптимизации
В качестве главного средства оптимизации я использовал AVX инструкции, конкретно набор AVX512. Идея заключается в том, чтобы рассчитывать сразу несколько пикселей за раз. 
Одно из направлений векторизации заключается в векторизации условных ветвлений. Для этого используются маски, которые позволяют вычисляющим инструкциям не трогать пиксели, расчёт для которых был закончен. Чтобы не использовать ассемблерные вставки и позволить компилятору оптимизировать код, я использовал SIMD команды

# Ход работы
1. Написал наивную реализацю
2. Написал оптимизированную реализацию
3. Измерил производительность оптимизировнной и наивной версии с учётом и без оптимизации компилятором. 
4. Воспользовался инструментом godbolt.org и сравнил фрагменты кода на Си и инструкции, которые получаются на выходе компилятор
5. Рассмотрел наивную реализацию, которая рассчитывает каждый пиксель отдельно
6. Рассмотрел векторизованную версию с использованием SIMD команд
7. Сделал вывод

# Сравнение выхода компилятора
Понятно, что компилятор не в силах додуматься обрабатывать сразу несколько пикселей за раз, как это делаем мы, поэтому приведу сравнение фрагмента кода для расчёта номера вылета пикселей.

```
    float x1_sqr   =          x1 * x1;
    float y1_sqr   =          y1 * y1;

    float dist_sqr = x1_sqr + y1 * y1;

    // if (dist_sqr > r_max_sqr + EPS)
    //     break;

    float dbl_x1y1 =      2 * x1 * y1;

    x1 = x1_sqr - y1_sqr + x0;
    y1 = dbl_x1y1        + y0;
```

## Наивная версия с `-O2`:
```
    movaps  xmm2, xmm0
    movaps  xmm3, xmm1
    mulss   xmm2, xmm0
    addss   xmm0, xmm0
    mulss   xmm3, xmm1
    mulss   xmm1, xmm0
    movaps  xmm4, xmm2
    subss   xmm2, xmm3
    addss   xmm4, xmm3
    addss   xmm1, xmm6
    movaps  xmm0, xmm2
    addss   xmm0, xmm5
```

Видно, что компилятор использует **XMM** регистры для расчётов с плавающей точкой, но этого недостаточно, чтобы ускорить производительность максимально, потому что делает он это лишь для одного пикселя. 

## Оптимизировнная версия с `-O2`:
```
    vmulps          zmm3, zmm0, zmm0
    vmovaps         zmm2, zmm1
    vmulps          zmm0, zmm1, zmm0
    vfmadd132ps     zmm2, zmm3, zmm1
    vfmsub132ps     zmm1, zmm3, zmm1
    vaddps          zmm0, zmm0, zmm0
    vaddps          zmm0, zmm0, zmm6
    vcmpps          k0,   zmm2, zmm7, 1
    vaddps          zmm1, zmm1, zmm5
    vpmovm2d        zmm2, k0
    vpaddd          zmm2, zmm2, zmm4
    vmovdqa64       zmm4, zmm2
```

Компилятор во всю использует **ZMM** регистры и сразу обрабатывает почти тем же количеством команд сразу 16 пикселей
___
Также компилятор имеет возможность оптимизировать интринсики. Чтобы не захламлять README огромными кусками кода привожу [ссылку](https://godbolt.org/z/bo83e879x) для сравнения оптимизацию кода с интринсиками

# Результаты замеров
Чтобы замерить именно производительность вычисления, проводил вычисления картинки фиксированное количество раз, в моём случае 100, и с его учётом измерял количество кадров в секунду. Так я смог пренебречь затратами на отрисовку кадра по сравнению с её расчётом, искусственно сместив вес вычислений. 

Я привёл результаты замеров с флагами `-O0` и `-O2` для того, чтобы показать:
1. Компилятор пытается использовать **XMM** регистры для ускорения расчётов с плавающей точкой
2. Компилятор может оптимизировать код, написанный с использованием интринсиков, в отличие от кода с ассемблерными вставками

**Оптимизированная**:
| FPS                    | `-O0` | `-O2` |
|------------------------|-------|-------|
|                        | 15.72 | 61.35 |
|                        | 15.28 | 65.54 |
|                        | 14.76 | 64.87 |
|                        | 15.69 | 63.04 |
|                        | 15.64 | 65.89 |
| Среднее                | 15.42 | 64.14 |
| Стандартное отклонение | 0.4   | 1.9   |

**Наивная**:
| FPS                    | `-O0` | `-O2` |
|------------------------|-------|-------|
|                        | 2.81  | 5.14  |
|                        | 2.92  | 5.20  |
|                        | 2.83  | 5.14  |
|                        | 2.77  | 5.19  |
|                        | 2.87  | 5.29  |
| Среднее                | 2.84  | 5.19  |
| Стандартное отклонение | 0.06  | 0.06  |

# Вывод
Таким образом, исходя из данных в таблице, я получил ускорение программы (сравнивая версии с оптимизациями компилятора) примерно в 12 раз

